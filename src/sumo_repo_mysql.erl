%%% @doc MySql repository implementation.
%%%
%%% Copyright 2012 Marcelo Gornstein &lt;marcelog@@gmail.com&gt;
%%%
%%% Licensed under the Apache License, Version 2.0 (the "License");
%%% you may not use this file except in compliance with the License.
%%% You may obtain a copy of the License at
%%%
%%%     http://www.apache.org/licenses/LICENSE-2.0
%%%
%%% Unless required by applicable law or agreed to in writing, software
%%% distributed under the License is distributed on an "AS IS" BASIS,
%%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%%% See the License for the specific language governing permissions and
%%% limitations under the License.
%%% @end
%%% @copyright Marcelo Gornstein <marcelog@gmail.com>
%%% @author Marcelo Gornstein <marcelog@gmail.com>
%%%
-module(sumo_repo_mysql).
-author("Marcelo Gornstein <marcelog@gmail.com>").
-github("https://github.com/marcelog").
-homepage("http://marcelog.github.com/").
-license("Apache License 2.0").

-include_lib("include/sumo_doc.hrl").
-include_lib("emysql/include/emysql.hrl").

-behavior(sumo_repo).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Exports.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Public API.
-export([
  init/1, create_schema/2, persist/2, find_all/2, find_all/5, find_by/3,
  find_by/5, delete/3, delete_all/2, execute/2, execute/3
]).
% -export([count/2]).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Types.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-record(state, {pool:: pid()}).
-type state() :: #state{}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% External API.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
persist(#sumo_doc{name=DocName}=Doc, State) ->
  % Set the real id, replacing undefined by 0 so it is autogenerated
  IdField = sumo:field_name(sumo:get_id_field(DocName)),
  NewId = case sumo:get_field(IdField, Doc) of
    undefined -> 0;
    Id -> Id
  end,
  NewDoc = sumo:set_field(IdField, NewId, Doc),

  [ColumnDqls, ColumnSqls, ColumnValues] = lists:foldl(
    fun({Name, Value}, [Dqls, Sqls, Values]) ->
      Dql = "`" ++ atom_to_list(Name) ++ "`",
      Sql = "?",
      [[Dql|Dqls], [Sql|Sqls], [Value|Values]]
    end,
    [[], [], []],
    NewDoc#sumo_doc.fields
  ),

  Dql = "INSERT INTO `"
    ++ atom_to_list(DocName) ++ "` (" ++ string:join(ColumnDqls, ",") ++ ")"
    ++ " VALUES (" ++ string:join(ColumnSqls, ",") ++ ")"
    ++ " ON DUPLICATE KEY UPDATE "
    ++ string:join(lists:map(
      fun(ColumnName) ->
        ColumnName ++ "=?"
      end,
      ColumnDqls
    ), ","),
  emysql:prepare(insert_stmt, list_to_binary(Dql)),
  Ok = execute(
    Dql, lists:append(ColumnValues, ColumnValues), State
  ),
  % XXX TODO darle una vuelta mas de rosca
  % para el manejo general de cuando te devuelve el primary key
  % considerar el caso cuando la primary key (campo id) no es integer
  % tenes que poner unique index en lugar de primary key
  % la mejor solucion es que el PK siempre sea un integer, como hace mongo
  LastId = case Ok#ok_packet.insert_id of
    0 -> NewId;
    I -> I
  end,
  IdField = sumo:field_name(sumo:get_id_field(DocName)),
  {ok, sumo:set_field(IdField, LastId, Doc), State}.

delete(DocName, Id, State) ->
  Sql = "DELETE FROM `" ++ atom_to_list(DocName)
    ++ "` WHERE `" ++ atom_to_list(sumo:field_name(sumo:get_id_field(DocName)))
    ++ "`=? LIMIT 1",
  Result = execute(Sql, [Id], State),
  {ok, Result#ok_packet.affected_rows > 0, State}.

delete_all(DocName, State) ->
  Sql = "DELETE FROM `" ++ atom_to_list(DocName) ++ "`",
  #ok_packet{} = execute(Sql, State),
  {ok, State}.

find_all(DocName, State) ->
  find_all(DocName, undefined, 0, 0, State).

find_all(DocName, OrderField, Limit, Offset, State) ->
  Sql0 =
    ["SELECT * FROM `", atom_to_list(DocName), "` "],
  Sql1 =
    case OrderField of
      undefined ->
        Sql0;
      _ ->
        [Sql0, " ORDER BY `", atom_to_list(OrderField), "` "]
    end,
  Sql2 =
    case Limit of
      0 ->
        Sql1;
      _ ->
        [Sql1, " LIMIT ", integer_to_list(Offset), ",", integer_to_list(Limit)]
    end,
  Query  = binary_to_list(iolist_to_binary(Sql2)),
  Result = execute(Query, State),
  Rows   = Result#result_packet.rows,
  Fields = Result#result_packet.field_list,
  Docs   = lists:foldl(
    fun(Row, DocList) ->
      NewDoc = lists:foldl(
        fun(Field, [Doc,N]) ->
          FieldRecord = lists:nth(N, Fields),
          FieldName = list_to_atom(binary_to_list(FieldRecord#field.name)),
          [sumo:set_field(FieldName, Field, Doc), N+1]
        end,
        [sumo:new_doc(DocName), 1],
        Row
      ),
      [hd(NewDoc)|DocList]
    end,
    [],
    Rows
  ),
  {ok, lists:reverse(Docs), State}.

%% XXX We should have a DSL here, to allow querying in a known language
%% to be translated by each driver into its own.
find_by(DocName, Conditions, Limit, Offset, State) ->
  [Sqls, Values] = lists:foldl(
    fun({Key, Value}, [CondSqls, CondValues]) ->
      [["`" ++ atom_to_list(Key) ++ "`=?"|CondSqls], [Value|CondValues]]
    end,
    [[],[]],
    Conditions
  ),
  Sql1 =
    "SELECT * FROM `" ++ atom_to_list(DocName) ++
    "` WHERE "++ string:join(Sqls, " AND "),
  Sql = case Limit of
    0 -> Sql1;
    _ ->
      Sql1 ++ " LIMIT " ++ integer_to_list(Offset) ++ ","
      ++ integer_to_list(Limit)
  end,
  Result = execute(Sql, Values, State),
  Rows = Result#result_packet.rows,
  Fields = Result#result_packet.field_list,
  Docs = lists:foldl(
    fun(Row, DocList) ->
      NewDoc = lists:foldl(
        fun(Field, [Doc,N]) ->
          FieldRecord = lists:nth(N, Fields),
          FieldName = list_to_atom(binary_to_list(FieldRecord#field.name)),
          [sumo:set_field(FieldName, Field, Doc), N+1]
        end,
        [sumo:new_doc(DocName), 1],
        Row
      ),
      [hd(NewDoc)|DocList]
    end,
    [],
    Rows
  ),
  {ok, lists:reverse(Docs), State}.

find_by(DocName, Conditions, State) ->
  find_by(DocName, Conditions, 0, 0, State).

%% XXX: Refactor:
%% Requires {length, X} to be the first field attribute in order to form the
%% correct query. :P
%% If no indexes are defined, will put an extra comma :P
%% Maybe it would be better to just use ALTER statements instead of trying to
%% create the schema on the 1st pass. Also, ALTER statements might be better
%% for when we have migrations.
create_schema(#sumo_schema{name=Name, fields=Fields}, State) ->
  FieldsDql = lists:map(fun create_column/1, Fields),
  Indexes = lists:filter(
    fun(T) -> length(T) > 0 end,
    lists:map(fun create_index/1, Fields)
  ),
  Dql = "CREATE TABLE IF NOT EXISTS "
  ++ "`" ++ atom_to_list(Name) ++ "` ("
  ++ string:join(FieldsDql, ",")
  ++ ","
  ++ string:join(Indexes, ",")
  ++ ") ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8",
  execute(Dql, State),
  {ok, State}.

create_column(#sumo_field{name=Name, type=integer, attrs=Attrs}) ->
  "`" ++ atom_to_list(Name) ++ "` INT(11) " ++ create_column_options(Attrs);

create_column(#sumo_field{name=Name, type=float, attrs=Attrs}) ->
  "`" ++ atom_to_list(Name) ++ "` FLOAT " ++ create_column_options(Attrs);

create_column(#sumo_field{name=Name, type=text, attrs=Attrs}) ->
  "`" ++ atom_to_list(Name) ++ "` TEXT " ++ create_column_options(Attrs);

create_column(#sumo_field{name=Name, type=binary, attrs=Attrs}) ->
  "`" ++ atom_to_list(Name) ++ "` BLOB " ++ create_column_options(Attrs);

create_column(#sumo_field{name=Name, type=string, attrs=Attrs}) ->
  "`" ++ atom_to_list(Name) ++ "` VARCHAR " ++ create_column_options(Attrs);

create_column(#sumo_field{name=Name, type=date, attrs=Attrs}) ->
  "`" ++ atom_to_list(Name) ++ "` DATE " ++ create_column_options(Attrs);

create_column(#sumo_field{name=Name, type=datetime, attrs=Attrs}) ->
  "`" ++ atom_to_list(Name) ++ "` DATETIME " ++ create_column_options(Attrs).

create_column_options(Attrs) ->
  lists:filter(fun(T) -> is_list(T) end, lists:map(
    fun(Option) ->
      create_column_option(Option)
    end,
    Attrs
  )).

create_column_option(auto_increment) ->
  "AUTO_INCREMENT ";

create_column_option(not_null) ->
  " NOT NULL ";

create_column_option({length, X}) ->
  "(" ++ integer_to_list(X) ++ ") ";

create_column_option(_Option) ->
  none.

create_index(#sumo_field{name=Name, attrs=Attrs}) ->
  lists:filter(fun(T) -> is_list(T) end, lists:map(
    fun(Attr) ->
      create_index(Name, Attr)
    end,
    Attrs
  )).

create_index(Name, id) ->
  "PRIMARY KEY(`" ++ atom_to_list(Name) ++ "`)";

create_index(Name, unique) ->
  List = atom_to_list(Name),
  "UNIQUE KEY `" ++ List ++ "` (`" ++ List ++ "`)";

create_index(Name, index) ->
  List = atom_to_list(Name),
  "KEY `" ++ List ++ "` (`" ++ List ++ "`)";

create_index(_, _) ->
  none.

% -spec total_posts(sumo_schema_name(), term() ) -> {ok, {raw, pos_integer}, term()} | {ok, error, term()}.
% count(DocName, State) ->
%   Sql = "SELECT COUNT(1) FROM `" ++ atom_to_list(DocName) ++ "`",
%   Result = sumo_repo_mysql:execute(Sql, State),
%   case Result of
%     #result_packet{rows=[[N]]} -> {ok, {raw, N}, State};
%     _ -> {ok, error, State}
%   end.

execute(Query, Args, #state{pool=Pool}) when is_list(Query), is_list(Args) ->
  ok = emysql:prepare(stmt, list_to_binary(Query)),
  lager:debug("Query: ~s ->  ~p ~n", [Query, Args]),
  emysql:execute(Pool, stmt, Args).

execute(Query, State) ->
  execute(Query, [], State).

init(Options) ->
  Pool = list_to_atom(erlang:ref_to_list(make_ref())),
  emysql:add_pool(
    Pool, 1,
    proplists:get_value(username, Options),
    proplists:get_value(password, Options),
    proplists:get_value(host, Options, "localhost"),
    proplists:get_value(port, Options, 3306),
    proplists:get_value(database, Options),
    proplists:get_value(encoding, Options, utf8)
  ),
  {ok, #state{pool=Pool}}.

